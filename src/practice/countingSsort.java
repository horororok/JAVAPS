package practice;

public class countingSsort {
    // 이 메서드는 입력된 배열에 계수 정렬을 수행합니다.
    public static void sortArray(int[] arr) {
        // 입력 배열에서 최댓값을 찾습니다.
        int max = arr[0]; // 처음 요소를 최댓값으로 가정합니다.
        for (int num : arr) {
            if (num > max) {
                max = num; // 더 큰 요소를 찾으면 최댓값을 업데이트합니다.
            }
        }
        
        // 0부터 최댓값까지의 인덱스를 가지는 'count' 배열을 생성합니다.
        int[] count = new int[max + 1]; // 각 요소의 빈도를 저장할 계수 배열입니다.
        
        // 입력 배열의 각 요소의 발생 빈도를 계산합니다.
        for (int num : arr) {
            count[num]++; // 해당 인덱스의 빈도를 증가시킵니다.
        }
        
        // 정렬된 값을 입력 배열에 다시 저장할 인덱스 변수를 준비합니다.
        int index = 0;
        
        // 계수 배열을 이용하여 정렬된 배열을 재구성합니다.
        for (int i = 0; i < count.length; i++) {
            while (count[i] > 0) {
                arr[index] = i; // 현재 인덱스 값을 입력 배열에 채웁니다.
                count[i]--; // 현재 인덱스의 빈도를 감소시킵니다.
                index++; // 입력 배열에서 다음 인덱스로 이동합니다.
            }
        }
    }
}
/*

	sortArray 메서드: 이 메서드는 입력된 배열에 계수 정렬을 수행하는 메서드입니다.

	최댓값 찾기:
	변수 max는 배열의 첫 번째 요소의 값으로 초기화됩니다. 이는 첫 번째 요소를 최댓값으로 가정하는 것입니다. 이후 더 큰 요소가 발견되면 max가 업데이트됩니다.
	루프는 "for-each" 루프 (for (int num : arr))를 사용하여 배열의 각 요소를 반복합니다.
	루프 내부에서 각 요소는 현재 max와 비교됩니다. 요소가 현재 max보다 크면 max를 새로운 요소 값으로 업데이트합니다.
	
	계수 배열 생성:
	길이가 max + 1인 배열 count를 생성합니다. 이 배열은 입력 배열에서 각 요소의 빈도를 저장합니다.
	
	빈도 계산:
	다른 루프는 입력 배열의 각 요소를 반복합니다.
	이 루프 내부에서 count 배열이 업데이트됩니다. 입력 배열의 각 요소 num에 대해 해당하는 인덱스의 count[num]가 증가됩니다.
	정렬된 배열 재구성:

	인덱스 변수 index는 입력 배열에 정렬된 요소를 다시 배치하기 위해 사용됩니다.
	
	재구성 루프:
	루프가 count 배열의 각 인덱스를 반복합니다.
	이 루프 내에서는 현재 인덱스의 빈도가 0보다 큰 동안 내부 while 루프가 실행됩니다.
	내부 루프 내에서 입력 배열은 현재 인덱스 값 (i)으로 채워집니다.
	현재 인덱스의 빈도가 감소되고, index가 증가하여 입력 배열의 다음 위치로 이동합니다.
	
	이 프로세스의 최종 결과는 입력 배열이 계수 정렬을 사용하여 오름차순으로 정렬된 상태가 됩니다. 이 알고리즘은 입력 배열의 값 범위가 정렬할 요소 수보다 크게 늘어나지 않을 때 효율적입니다.
 
 */